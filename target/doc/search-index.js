var searchIndex = {};
searchIndex["server"] = {"doc":"Offline MEA Server The offline server implements the same API as the MEA server, however instead of getting its data from the MEA it gets its data from an offline CSV file. This means it can be used instead of the MEA server when the MEA server is not available (e.g. poor network connection at conferences or that the MEA is not connected to the server). The server is written in Rust. To follow some of the more technical aspects of the discussion below, it is recommended to have an idea of what the Rust ownership system is. The following discussion is a bit simplified to be easy to follow for people who have not written specifically in Rust.","items":[[3,"Config","server","Struct to represent the config.json-file.",null,null],[12,"http_port","","What port the HTTP server should be listening on.",0,null],[12,"tcp_port","","What port the TCP server should be listening on.",0,null],[5,"main","","Starts the different threads.",null,{"inputs":[],"output":null}],[0,"tcp","","This module sets up a TCP server. When a client is connected it will receive segments when the server is running. When a HTTP stop request is received, all TCP clients are kicked. Each TCP client connection gets its own TCP client manager that sends segments to the clients.",null,null],[3,"Server","server::tcp","Represents the state of the server.",null,null],[12,"clients","","",1,null],[12,"listener","","",1,null],[6,"ClientTx","","The type for transmitting data to a TCP client.",null,null],[6,"Clients","","Represents a HashMap of Clients. It will have their addresses and their transmit side of the channel.",null,null],[11,"bind","","Binds the TCP server to the specified address.",1,{"inputs":[{"name":"socketaddr"}],"output":{"name":"server"}}],[11,"get_clients","","Gets a reference counted reference to the clients HashMap.",1,{"inputs":[{"name":"self"}],"output":{"generics":["mutex"],"name":"arc"}}],[11,"run","","Runs the server, setting up the green threaded event loop.",1,{"inputs":[{"name":"self"}],"output":null}],[0,"http","server","This module sets up a HTTP server accepting incoming requests. A client may send a POST request to start and stop the server using specified parameters.",null,null],[3,"Server","server::http","Create an object that can be called from main.",null,null],[3,"HttpService","","Create the HttpService that will be created for each HTTP request:",null,null],[12,"running","","",2,null],[12,"command_tx","","",2,null],[11,"new","","Create a new server.",3,{"inputs":[],"output":{"name":"server"}}],[11,"run","","Run the server.",3,{"inputs":[{"name":"self"},{"name":"socketaddr"},{"name":"sender"}],"output":null}],[11,"call","","Parse the request and generate a response.",2,null],[0,"controller","server","This module is the controller of the system. It receives start and stop commands from the HTTP module (when the HTTP module receives start and stop requests). When the server is started, it will read segments from the offline file and send them to each of the connected TCP client managers.",null,null],[3,"Config","server::controller","Represents the server state and is configured using the POST /start.",null,null],[12,"sample_rate","","The sample rate when sampling the MEA.",4,null],[12,"segment_length","","The number of samples to send for each channel each time.",4,null],[3,"Sample","","Represents a single line in the CSV file.",null,null],[12,"timestamp","","The timestamp value.",5,null],[12,"values","","The 60 voltage values.",5,null],[3,"Controller","","The controller data struct.",null,null],[12,"command_rx","","Receives commands from the HTTP module.",6,null],[12,"clients","","List of TCP clients to send CSV data to.",6,null],[12,"config","","The global server config.",6,null],[12,"samples","","A vector containing a buffered file reader (performance) for each channel.",6,null],[12,"last_segment_finished","","Keep track of when the last segment was sent so we know when to send the next one.",6,null],[4,"Command","","The command to send on the Command channel.",null,null],[13,"Start","","Start the server with the specified Config.",7,null],[13,"Stop","","Stop the server.",7,null],[5,"duration_from_micros","","Creates a Duration object from microseconds.",null,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[6,"Running","","Represents a running state.",null,null],[6,"CommandTx","","The type for the sending side of the Command channel.",null,null],[6,"CommandRx","","The type for the receiving side of the Command channel.",null,null],[17,"_IMPL_DESERIALIZE_FOR_Config","","",null,null],[17,"_IMPL_DESERIALIZE_FOR_Sample","","",null,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"config"}}],[11,"new","","",6,{"inputs":[{"name":"receiver"},{"generics":["mutex"],"name":"arc"},{"generics":["string"],"name":"option"}],"output":{"name":"controller"}}],[11,"update_config","","Update the global config into the local config variable.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"sleep_until","","Simple implementation of a sleep until function.",6,{"inputs":[{"name":"self"},{"name":"instant"}],"output":null}],[11,"collect_segment","","Collect a segment from the cache.",6,{"inputs":[{"name":"self"}],"output":{"name":"bytes"}}],[11,"run","","Run the controller loop.",6,{"inputs":[{"name":"self"}],"output":null}],[17,"_IMPL_DESERIALIZE_FOR_Config","server","",null,null]],"paths":[[3,"Config"],[3,"Server"],[3,"HttpService"],[3,"Server"],[3,"Config"],[3,"Sample"],[3,"Controller"],[4,"Command"]]};
initSearch(searchIndex);
