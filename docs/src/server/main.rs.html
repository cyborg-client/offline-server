<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="Source to the Rust file `src/main.rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang">

    <title>main.rs.html -- source</title>

    <link rel="stylesheet" type="text/css" href="../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle">
    
    <link rel="stylesheet" type="text/css" href="../../dark.css">
    <link rel="stylesheet" type="text/css" href="../../main.css" id="themeStyle">
    <script src="../../storage.js"></script>
    

    
    
</head>
<body class="rustdoc source">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        
    </nav>

    <div class="theme-picker">
        <button id="theme-picker" aria-label="Pick another theme!">
            <img src="../../brush.svg" width="18" alt="Pick another theme!">
        </button>
        <div id="theme-choices"></div>
    </div>
    <script src="../../theme.js"></script>
    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
</pre><pre class="rust ">
<span class="doccomment">//! # Offline MEA Server</span>
<span class="doccomment">//! The offline server implements the same API as the MEA server, however instead of getting its data from the MEA it gets its data from an offline CSV file. This means it can be used instead of the MEA server when the MEA server is not available (e.g. poor network connection at conferences or that the MEA is not connected to the server).</span>

<span class="doccomment">//! The server is written in Rust. To follow some of the more technical aspects of the discussion below, it is recommended to have an idea of what the Rust ownership system is. The following discussion is a bit simplified to be easy to follow for people who have not written specifically in Rust.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Overview over memory management</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! We now turn to the memory management problem of the server. The server listens to HTTP connections for configuring the server state. The state is whether the server is running, the segment length and the sample rate of transmission. When the server is running, it is accepting TCP connections. When a client connects it will start receiving data. The first byte it receives will be from a segment boundary. This means that if the server is currently recording in the middle of a segment, the server will wait until a new segment boundary is started before sending data to this new client.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Since the TCP data is streamed over the internet, there might be temporary disruptions in the connection and other issues that cause the OS&#39;s TCP sending buffer to fill completely. To stop this from disconnecting clients as soon as this happens, we want to buffer the MEA data for as long as needed (up to a certain threshold where the client is kicked for being too slow at receiving). When all the connected clients have received a given segment it should go out of scope to free the memory.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! To achieve this, we have created a queue of segments for each TCP client. Since we do not know at compile time which clients will connect, we cannot prove who will get a reader reference, so we will not know when there are zero references to the data, and the compiler cannot infer when to delete the data. To allow for having multiple readers created on runtime, we can use a reference counted wrapper for the segment data. This counts all the created references on runtime, and decreases the counter when a reference goes out of scope. This upholds the invariants demanded by the ownership system on runtime. This means there will be a small but necessary runtime penalty for doing this.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! At last we can describe how the memory of the segments are managed. In short a controller module generates segments which are wrapped in reference counted objects. Each of these segments are then sent on a bounded buffered channel to each TCP client manager. If the bounded buffer is full the TCP connection will be closed. In other words if the TCP backpressure gets too large, we terminate the connection. Each TCP client manager reads from the channel, sends the segments onto the network. Since each segment is sent as a whole to each TCP client manager we ensure that each TCP client receives data from a segment boundary. When the data is sent on the network the segment goes out of scope. When all TCP client managers have sent the data and let the segment reference go out of scope, there are zero references to the segment, and it is then deleted by the ownership system. If a channel gets full the TCP connection is closed, and the buffer is deleted. This means all the contained segment references go out of scope, and finally the segments are deleted. In other words all segments are stored for as long as needed, and deleted as soon as possible keeping the memory footprint as low as possible.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Architecture and language for Offline MEA Server</span>
<span class="doccomment">//! ### Why Rust?</span>
<span class="doccomment">//! We decided to use Rust for our server because it runs as fast as highly optimized C++ code. In addition it only accepts safe code so that we were much less likely to encounter runtime bugs. This was an important trait for this project as we did not have much time to do runtime debugging. Instead we could rely on Rust&#39;s safe type system to eliminate most of the bugs. This means that when the program compiles and runs without a bug once, it will likely run without any bugs for a long time.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Considering the above one might wonder why we used Rust only for the server, and not for the client program. One important reason is that in order for Rust to accomplish its speed and safety it enforces a strict type system that takes some time to learn. If the code cannot be proved by the compiler to be safe, it will not compile. This makes it unsuitable for use by people who do not already know Rust or are not experienced C++ programmers (or experienced in any other language that supports raw pointers). Since only one person was already fluent in Rust, he was assigned the responsibility of the offline MEA server.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Architectural choices</span>
<span class="doccomment">//! #### The segment memory management structure</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! We chose the memory management technique described because it is a very easy solution to the problem. However it also means that each segment gets its own object on the heap. This is fairly expensive because the segments will not be located in the CPU Lx-caches, resulting in an allocation and usage cost of about 200 times longer than if we had used pre-allocated segments. This solution is something to look into if the server is to be run on cheap hardware.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### The cache</span>
<span class="doccomment">//! When developing the program, we simply chose the first CSV library we found on crates.io. We have not had time to compare it to other libraries, so we do not know whether or not it is poorly implemented or not. However after running a quick profile of the program, close to 99 % of the CPU time was spent in the CSV library. To decrease the CPU usage, we implemented a cache instead of reading from the CSV file directly. This was necessary because the server couldn&#39;t run in real-time on a laptop. If we would have had more time available we would try different CSV libraries as an alternative to using cache files. This is because using a cache makes the system more complicated than necessary.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### The green thread model</span>
<span class="doccomment">//! We chose to use Tokio with a green threading model mainly because Hyper (HTTP library) is built on top of Tokio. This means if we were to use Hyper, we would need to use Tokio as well. Using Tokio means the server will be able to scale from one to millions of clients with little change in needed CPU power. This is because in a server where all network connections are handled in its own thread spends most of its time switching OS threads. However since we are only going to have a few clients, using a green thread model is a bit overkill if there were no other reasons to use Tokio.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! One advantage of using Tokio is that each process can be represented by functional programming. This is a very efficient approach to implementing client-server functionality. This means we could pipe data with very little effort. The main disadvantage of using Tokio and futures in Rust is that the syntax is still in its infancy. There is a crate adding macros for using async/await syntax, however since this is still experimental, we decided not to use this. In the future we would have used an async/await syntax to make the code much easier to read.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Overview over main</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! This module parses command parameters and the config file, and starts all the other modules in their own threads. Finally it joins on all the threads in order to keep the program alive until all modules have stopped. Currently stopping functionality is not implemented. Instead you just kill the program using any code as there is no cleanup to be done.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### More detailed overview</span>
<span class="doccomment">//! The main module reads the command parameters and the config parameters. To set up the server it creates a vector that will contain all threads the main thread should join. Main then starts the HTTP server in a new thread by calling http::Server::new().run(&amp;Addr, CommandTx). It then proceeds to start the TCP server in a similar way. It then extracts a reference to the TCP clients list from the TCP server object. Lastly the Controller is started in a separate thread, and is initialized with the CommandRx and Clients list. In addition it is passed either None or Some(filename). If Some(filename) is specified, the controller will generate a cache from the specified CSV file. If None is specified, the controller will run on the cache.</span>
<span class="doccomment">//!</span>

<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">byteorder</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">bytes</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">futures</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">hyper</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_derive</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_json</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tokio</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tokio_io</span>;

<span class="kw">mod</span> <span class="ident">tcp</span>;
<span class="kw">mod</span> <span class="ident">http</span>;
<span class="kw">mod</span> <span class="ident">controller</span>;

<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">fs</span>, <span class="ident">thread</span>};
<span class="kw">use</span> <span class="ident">controller</span>::<span class="ident">Controller</span>;


<span class="doccomment">/// Struct to represent the config.json-file.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Config</span> {
    <span class="doccomment">/// What port the HTTP server should be listening on.</span>
    <span class="ident">http_port</span>: <span class="ident">u16</span>,
    <span class="doccomment">/// What port the TCP server should be listening on.</span>
    <span class="ident">tcp_port</span>: <span class="ident">u16</span>,
}

<span class="doccomment">/// Starts the different threads.</span>
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Parse the input arguments:</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">args</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">env</span>::<span class="ident">args</span>();
    <span class="kw">let</span> <span class="ident">mode</span> <span class="op">=</span> <span class="ident">args</span>.<span class="ident">nth</span>(<span class="number">1</span>).<span class="ident">unwrap</span>();

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">controller_input</span> <span class="op">=</span> <span class="prelude-val">None</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">run</span> <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="kw">match</span> <span class="ident">mode</span>.<span class="ident">as_str</span>() {
        <span class="string">&quot;run&quot;</span> <span class="op">=&gt;</span> <span class="ident">controller_input</span> <span class="op">=</span> <span class="prelude-val">None</span>,
        <span class="string">&quot;build&quot;</span> <span class="op">=&gt;</span> <span class="ident">controller_input</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">args</span>.<span class="ident">next</span>().<span class="ident">expect</span>(<span class="string">&quot;No filename given.&quot;</span>)),
        <span class="string">&quot;clear&quot;</span> <span class="op">=&gt;</span> {
            <span class="ident">run</span> <span class="op">=</span> <span class="bool-val">false</span>;
            <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">60</span> {
                <span class="kw">let</span> _ <span class="op">=</span> <span class="ident">fs</span>::<span class="ident">remove_file</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;.{}.dat&quot;</span>, <span class="ident">i</span>));
            }
        },
        <span class="string">&quot;help&quot;</span> <span class="op">=&gt;</span> {
            <span class="ident">run</span> <span class="op">=</span> <span class="bool-val">false</span>;
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">r#&quot;Available commands:
    build &lt;filename&gt;.csv - Builds the cache using the supplied CSV file.
    run - Runs the server using the files built using &quot;build &lt;filename&gt;.csv&quot;
    clear - Clears the cached files.
    help - Shows this help information.&quot;#</span>);
        }
        _ <span class="op">=&gt;</span> {
            <span class="macro">eprintln</span><span class="macro">!</span>(<span class="string">&quot;Invalid arguments. Try running with help.&quot;</span>);
            <span class="ident">std</span>::<span class="ident">process</span>::<span class="ident">exit</span>(<span class="number">1</span>);
        },
    };

    <span class="kw">if</span> <span class="op">!</span><span class="ident">run</span> {
        <span class="ident">std</span>::<span class="ident">process</span>::<span class="ident">exit</span>(<span class="number">0</span>);
    }


    <span class="comment">// Get the ports from the config file:</span>
    <span class="kw">let</span> <span class="ident">config_file</span> <span class="op">=</span> <span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">open</span>(<span class="string">&quot;config.json&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;Could not open config.json&quot;</span>);
    <span class="kw">let</span> <span class="ident">config</span>: <span class="ident">Config</span> <span class="op">=</span> <span class="ident">serde_json</span>::<span class="ident">from_reader</span>(<span class="ident">config_file</span>).<span class="ident">expect</span>(<span class="string">&quot;The config is missing one or more element.&quot;</span>);

    <span class="comment">// Create a thread handle vector on which to let main join:</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">threads</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();

    <span class="comment">// Create channels for communication between HTTP handler and Controller thread:</span>
    <span class="kw">let</span> (<span class="ident">command_tx</span>, <span class="ident">command_rx</span>) <span class="op">=</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">mpsc</span>::<span class="ident">channel</span>();

    <span class="comment">// Start HTTP handler:</span>
    <span class="kw">let</span> <span class="ident">http_addr</span> <span class="op">=</span> (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;0.0.0.0:&quot;</span>) <span class="op">+</span> <span class="kw-2">&amp;</span><span class="ident">config</span>.<span class="ident">http_port</span>.<span class="ident">to_string</span>()).<span class="ident">parse</span>().<span class="ident">unwrap</span>();
    <span class="ident">threads</span>.<span class="ident">push</span>(<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> {
        <span class="ident">http</span>::<span class="ident">Server</span>::<span class="ident">new</span>().<span class="ident">run</span>(<span class="kw-2">&amp;</span><span class="ident">http_addr</span>, <span class="ident">command_tx</span>);
    }));

    <span class="comment">// Start the TCP connection manager:</span>
    <span class="kw">let</span> <span class="ident">tcp_addr</span> <span class="op">=</span> (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;0.0.0.0:&quot;</span>) <span class="op">+</span> <span class="kw-2">&amp;</span><span class="ident">config</span>.<span class="ident">tcp_port</span>.<span class="ident">to_string</span>()).<span class="ident">parse</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">tcp_server</span> <span class="op">=</span> <span class="ident">tcp</span>::<span class="ident">Server</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">tcp_addr</span>);

    <span class="comment">// The TCP server keeps a list of connected clients. Get a reference to this list:</span>
    <span class="kw">let</span> <span class="ident">clients</span> <span class="op">=</span> <span class="ident">tcp_server</span>.<span class="ident">get_clients</span>();

    <span class="ident">threads</span>.<span class="ident">push</span>(<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> {
        <span class="ident">tcp_server</span>.<span class="ident">run</span>();
    }));

    <span class="comment">// Create and start the Controller:</span>
    <span class="ident">threads</span>.<span class="ident">push</span>(<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> {
        <span class="kw">let</span> <span class="ident">controller</span> <span class="op">=</span> <span class="ident">Controller</span>::<span class="ident">new</span>(<span class="ident">command_rx</span>, <span class="ident">clients</span>, <span class="ident">controller_input</span>);
        <span class="ident">controller</span>.<span class="ident">run</span>();
    }));


    <span class="comment">// Finally join on all threads:</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="ident">threads</span> {
        <span class="ident">i</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>();
    }
}</pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt><kbd>?</kbd></dt>
                    <dd>Show this help dialog</dd>
                    <dt><kbd>S</kbd></dt>
                    <dd>Focus the search field</dd>
                    <dt><kbd>↑</kbd></dt>
                    <dd>Move up in search results</dd>
                    <dt><kbd>↓</kbd></dt>
                    <dd>Move down in search results</dd>
                    <dt><kbd>↹</kbd></dt>
                    <dd>Switch tab</dd>
                    <dt><kbd>&#9166;</kbd></dt>
                    <dd>Go to active search result</dd>
                    <dt><kbd>+</kbd></dt>
                    <dd>Expand all sections</dd>
                    <dt><kbd>-</kbd></dt>
                    <dd>Collapse all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "server";
    </script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>